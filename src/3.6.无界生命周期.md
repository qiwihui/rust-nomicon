原文链接：<https://doc.rust-lang.org/nomicon/unbounded-lifetimes.html>

# 无界生命周期

非安全代码经常会凭空变出来一些引用和生命周期。这些生命周期都是无界的。最常见的场景是解引用一个裸指针，然后产生一个拥有无界生命周期的引用。这些生命周期根据上下文的要求，想要多大就可以有多大。这其实比简单的设为`'static`更加强大。比如`&'static &'a T`是无法通过类型检查的，但是无界生命周期可以完美适配`&'a &'a T`。不过大多数情况下，这种的无界生命周期会被视为`'static'。

几乎没有哪个引用是`'static`，所以这样很可能是错误的。`transmute`和`transmute_copy`是两种很主要的例外情况。我们应该尽量早的确定无界生命周期的边界，特别是在涉及到函数调用的情况下。

对于一个函数，任何不是从输入那里来的输出生命周期都是无界的。比如：

```rust
fn get_str<'a>() -> &'a str;
```

这个函数会产生一个拥有无界生命周期的`&str`。最简单的避免无界生命周期的方式就是在函数声明中运用生命周期省略。如果一个输出生命周期被省略了，它必须受限于一个输入生命周期。当然它有可能被赋予了一个错误的生命周期，但是这样通常只会产生一个编译错误，总比允许它破坏内存安全要好。

在函数的内部，限制生命周期范围是极容易出错的。最安全且简单的限制生命周期的方法是将它作为一个有有界生命周期的函数的返回值。但是，如果这个不被接受，引用可以被设置成一个特别的生命周期。不幸的是，我们不可能为函数所有的生命周期命名。（*译注：我真的没看懂这一段在说什么……强烈建议看原文，不要看我*）