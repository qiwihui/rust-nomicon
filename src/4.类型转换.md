原文链接：<https://doc.rust-lang.org/nomicon/conversions.html>

# 类型转换

到目前为止，我们的程序还是一堆散乱的字节，而类型系统拍马赶到教给我们如何正确使用这些字节。将字节翻译成有意义的类型，这件事有两个主要问题：将完全相同的一组字节解析成不同的类型，以及让不同的字节在不同的类型中有相同的含义。因为Rust喜欢将一些重要的属性附加在类型上，这些问题就变得尤其普遍。所以Rust也提供了许多方法解决这一问题。

我们先来看看安全Rust如何重新解析值。最普通的方法是将值的各个组成部分拆分出来，再用它们重新构建一个新的类型的值。例如

```rust
struct Foo {
    x: u32,
    y: u16,
}

struct Bar {
    a: u32,
    b: u16,
}

fn reinterpret(foo: Foo) -> Bar {
    let Foo { x, y } = foo;
    Bar { a: x, b: y }
}
```

可是这种方法显然很烦人。对于一般的类型转换场景，Rust提供了更加人性化的选择。